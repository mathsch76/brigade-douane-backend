// ğŸ”„ FORCE REDEPLOY - 31/07/2025 - 06:15


/**
 * ğŸ¤– SERVICE ASSISTANT OPENAI - VERSION AVEC TRACKING COMPLET
 * Gestion centralisÃ©e des interactions OpenAI et threads + sauvegarde tokens
 */

const { supabase } = require('../utils/supabase');
import { generateCacheKey, getCachedResponse, setCachedResponse } from './cacheService';
import { OpenAI } from 'openai';
import logger from '../utils/logger';
import config from '../utils/config';
import { 
  enterpriseCache, 
generateCacheKey as generateThreadCacheKey,
getCachedAssistantId,
  cacheAssistantId
} from '../utils/assistantCache';
import { 
  getUserPreferences, 
  buildCustomInstructions,
  type UserPreferences,
  type CachedThreadData
} from './preferencesService';

// ğŸ”§ CLIENT OPENAI CONFIGURÃ‰
const openai = new OpenAI({
  apiKey: config.openai.apiKey,
  defaultHeaders: {
    "OpenAI-Beta": "assistants=v2",
  },
});

// ğŸ¯ CONFIGURATION DES ASSISTANTS
const ASSISTANTS: Record<string, string | undefined> = {
  'EMEBI ET TVA UE': process.env.ASSISTANT_EMEBI,
  'MACF': process.env.ASSISTANT_MACF,
  'CODE DES DOUANES UE': process.env.ASSISTANT_CODE_DOUANES,
  'USA': process.env.ASSISTANT_USA,
  'EUDR': process.env.ASSISTANT_EUDR,
  'SANCTIONS RUSSES': process.env.ASSISTANT_SANCTIONS
};
// ğŸ“Š INTERFACE POUR SAUVEGARDE TOKENS
interface TokenUsageData {
  user_id: string;
  company_id: string;
  bot_id: string;
  thread_id: string;
  run_id: string;
  total_tokens: number;
  input_tokens: number;
  output_tokens: number;
  response_time_ms: number;
  timestamp: string;
}

// ğŸ’¾ FONCTION DE SAUVEGARDE TOKENS (NOUVELLE)
/**
 * Sauvegarde les donnÃ©es d'usage des tokens dans Supabase
 */
async function saveTokenUsage(data: TokenUsageData): Promise<void> {
  try {
    const { error } = await supabase
      .from('openai_token_usage')
      .insert({
        user_id: data.user_id,
        company_id: data.company_id,
        bot_id: data.bot_id,
        thread_id: data.thread_id,
        run_id: data.run_id,
        total_tokens: data.total_tokens,
        input_tokens: data.input_tokens,
        output_tokens: data.output_tokens,
        response_time_ms: data.response_time_ms,
        timestamp: data.timestamp
      });

    if (error) {
      logger.error('âŒ Erreur sauvegarde tokens', { 
        error: error.message,
        userId: data.user_id,
        botId: data.bot_id 
      });
    } else {
      logger.debug('âœ… Tokens sauvegardÃ©s', { 
        userId: data.user_id,
        botId: data.bot_id,
        tokens: data.total_tokens,
        responseTime: data.response_time_ms 
      });
    }
  } catch (error) {
    logger.error('âŒ Exception sauvegarde tokens', { 
      error: (error as Error).message,
      userId: data.user_id 
    });
  }
}

// ğŸ” FONCTION POUR RÃ‰CUPÃ‰RER COMPANY_ID
/**
 * RÃ©cupÃ¨re le company_id d'un utilisateur
 */
async function getUserCompanyId(userId: string): Promise<string | null> {
  try {
    const { data, error } = await supabase
      .from('users')
      .select('company_id')
      .eq('id', userId)
      .single();

    if (error || !data) {
      logger.warn('âš ï¸ Company ID introuvable', { userId, error: error?.message });
      return null;
    }

    return data.company_id;
  } catch (error) {
    logger.error('âŒ Erreur rÃ©cupÃ©ration company_id', { 
      userId, 
      error: (error as Error).message 
    });
    return null;
  }
}

// ğŸ§µ GESTION DES THREADS (INCHANGÃ‰)

/**
 * RÃ©cupÃ¨re ou crÃ©e un thread avec prÃ©fÃ©rences (version optimisÃ©e)
 */
export async function getQuickThread(userId: string, chatbotId: string): Promise<CachedThreadData> {
  const cacheKey = generateThreadCacheKey(userId, chatbotId);
  
  // âš¡ Cache hit
  const cached = enterpriseCache.get(cacheKey);
  if (cached) {
    logger.debug('âš¡ Cache hit thread', { userId, chatbotId });
    return cached;
  }

  try {
    // ğŸ” RequÃªte unique optimisÃ©e
    const [threadData, prefsData] = await Promise.all([
      supabase.from('user_threads')
        .select('thread_id, last_used_at')
        .eq('user_id', userId)
        .eq('chatbot_id', chatbotId)
        .maybeSingle(),
      getUserPreferences(userId, chatbotId)
    ]);

    const preferences = prefsData;
    let threadId: string;
    
    // Thread existant et rÃ©cent ? (moins d'1h)
    if (threadData.data && (Date.now() - new Date(threadData.data.last_used_at).getTime()) < 3600000) {
      threadId = threadData.data.thread_id;
      // Update async sans attendre
      setImmediate(() => {
        supabase.from('user_threads')
          .update({ last_used_at: new Date().toISOString() })
          .eq('user_id', userId)
          .eq('chatbot_id', chatbotId)
          .then(() => logger.debug('Thread timestamp updated'))
          .catch(() => logger.warn('Failed to update thread timestamp'));
      });
    } else {
      // CrÃ©er nouveau thread
      const thread = await openai.beta.threads.create();
      threadId = thread.id;
      
      // Sauver async sans attendre
      setImmediate(() => {
        supabase.from('user_threads').upsert({
          user_id: userId, 
          chatbot_id: chatbotId, 
          thread_id: threadId,
          created_at: new Date().toISOString(), 
          last_used_at: new Date().toISOString(), 
          message_count: 0
        }, { onConflict: 'user_id,chatbot_id' })
        .then(() => logger.debug('Thread saved to DB'))
        .catch(() => logger.warn('Failed to save thread to DB'));
      });
    }

    const result = { threadId, preferences };
    enterpriseCache.set(cacheKey, result);
    return result;

  } catch (error) {
    logger.error('âŒ Erreur thread', { error: (error as Error).message });
    // Fallback : crÃ©er thread temporaire
    const thread = await openai.beta.threads.create();
    return { 
      threadId: thread.id, 
      preferences: { contentLevel: 'intermediate', communicationStyle: 'professional' }
    };
  }
}

// ğŸ¤– GESTION DES ASSISTANTS (INCHANGÃ‰)

/**
 * RÃ©cupÃ¨re l'assistant ID avec validation
 */
export function getAssistantId(chatbotId: string): string | null {
  // VÃ©rifier cache d'abord
  const cached = getCachedAssistantId(chatbotId);
  if (cached) {
    return cached;
  }

  // RÃ©cupÃ©rer depuis la config
  const assistantId = ASSISTANTS[chatbotId];
  if (!assistantId) {
    logger.error(`âŒ Assistant non configurÃ©`, { chatbotId, available: Object.keys(ASSISTANTS) });
    return null;
  }

  // Mettre en cache
  cacheAssistantId(chatbotId, assistantId);
  return assistantId;
}

/**
 * RÃ©cupÃ¨re la liste des bots disponibles
 */
export function getAvailableBots(): string[] {
  return Object.keys(ASSISTANTS).filter(bot => ASSISTANTS[bot]);
}

// ğŸ”„ GESTION DES RUNS (INCHANGÃ‰)

/**
 * Attend la complÃ©tion d'un run OpenAI - VERSION CORRIGÃ‰E
 */
export async function waitForRunCompletion(threadId: string, runId: string): Promise<any> {
  // ğŸ” DEBUG - VÃ©rifier les paramÃ¨tres reÃ§us
  console.log('ğŸ” DEBUG waitForRunCompletion - threadId:', threadId);
  console.log('ğŸ” DEBUG waitForRunCompletion - runId:', runId);
  
  // âœ… VALIDATION STRICTE DES PARAMÃˆTRES
  if (!threadId || threadId === 'undefined') {
    throw new Error(`ThreadId invalide: ${threadId}`);
  }
  
  if (!runId || runId === 'undefined') {
    throw new Error(`RunId invalide: ${runId}`);
  }
  
  // âœ… VÃ‰RIFIER QUE C'EST BIEN UN THREAD ID (commence par "thread_")
  if (!threadId.startsWith('thread_')) {
    console.error('âŒ ERREUR PARAMÃˆTRES - threadId ne commence pas par thread_:', threadId);
    console.error('âŒ ERREUR PARAMÃˆTRES - runId reÃ§u:', runId);
    throw new Error(`ThreadId invalide (ne commence pas par thread_): ${threadId}`);
  }
  
  // âœ… VÃ‰RIFIER QUE C'EST BIEN UN RUN ID (commence par "run_")
  if (!runId.startsWith('run_')) {
    console.error('âŒ ERREUR PARAMÃˆTRES - runId ne commence pas par run_:', runId);
    console.error('âŒ ERREUR PARAMÃˆTRES - threadId reÃ§u:', threadId);
    throw new Error(`RunId invalide (ne commence pas par run_): ${runId}`);
  }

  // ğŸš¨ DEBUG EXTRÃŠME - JUSTE AVANT L'APPEL OPENAI
  console.log('ğŸš¨ DEBUG EXTRÃŠME - JUSTE AVANT OPENAI CALL');
  console.log('ğŸš¨ threadId type:', typeof threadId);
  console.log('ğŸš¨ threadId value:', JSON.stringify(threadId));
  console.log('ğŸš¨ runId type:', typeof runId);
  console.log('ğŸš¨ runId value:', JSON.stringify(runId));
  console.log('ğŸš¨ ParamÃ¨tres Ã  envoyer Ã  OpenAI:', { threadId, runId });

  try {
    // âœ… CORRECTION CRITIQUE : threadId EN PREMIER !
    console.log('ğŸš¨ APPEL OPENAI AVEC:', `threadId="${threadId}", runId="${runId}"`);
    let runStatus = await openai.beta.threads.runs.retrieve(runId, { thread_id: threadId });
    console.log('ğŸš¨ APPEL OPENAI RÃ‰USSI !');
    
    let attempts = 0;
    const maxAttempts = 60; // 60 secondes max
    
    while (runStatus.status === 'queued' || runStatus.status === 'in_progress') {
      if (attempts >= maxAttempts) {
        throw new Error(`Timeout: Run ${runId} a pris plus de ${maxAttempts} secondes`);
      }
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // ğŸš¨ DEBUG AUSSI LE DEUXIÃˆME APPEL
      console.log('ğŸš¨ DEUXIÃˆME APPEL OPENAI AVEC:', `threadId="${threadId}", runId="${runId}"`);
      runStatus = await openai.beta.threads.runs.retrieve(threadId, runId);
      console.log('ğŸš¨ DEUXIÃˆME APPEL RÃ‰USSI !');
      attempts++;
      
      logger.debug(`ğŸ”„ Run status: ${runStatus.status}`, { threadId, runId, attempt: attempts });
    }
    
    if (runStatus.status !== 'completed') {
      logger.error(`âŒ Run failed`, { threadId, runId, status: runStatus.status });
    }
    
    return runStatus;
    
  } catch (error) {
    console.error('ğŸš¨ ERREUR DANS WAITFORRUNCOMPLETION:', error);
    console.error('ğŸš¨ ERREUR - threadId Ã©tait:', threadId);
    console.error('ğŸš¨ ERREUR - runId Ã©tait:', runId);
    throw error;
  }
}
  
// ğŸš€ FONCTION PRINCIPALE DE TRAITEMENT (MODIFIÃ‰E)

/**
 * Traite une question avec un assistant spÃ©cifique + SAUVEGARDE TOKENS
 */
export async function processAssistantQuestion(
  userId: string,
  chatbotId: string,
  question: string,
  providedPreferences?: UserPreferences
): Promise<{
  answer: string;
  tokens_used: number;
  preferences_applied: UserPreferences;
}> {
  const globalStartTime = Date.now();

try {
  console.log('ğŸ” DEBUG processAssistantQuestion - DÃ‰BUT');
  console.log('ğŸ” DEBUG userId:', userId);
  console.log('ğŸ” DEBUG chatbotId:', chatbotId);
  console.log('ğŸ” DEBUG question:', question?.substring(0, 50) + '...');
  
// 1. RÃ©cupÃ©rer l'assistant ID
console.log('ğŸ” DEBUG - Avant getAssistantId');
const assistantId = getAssistantId(chatbotId);
console.log('ğŸ” DEBUG - Assistant ID rÃ©cupÃ©rÃ©:', assistantId);
if (!assistantId) {
  throw new Error(`Bot ${chatbotId} non configurÃ©`);
}

console.log('ğŸ” DEBUG - Avant getUserCompanyId');
// 2. RÃ©cupÃ©rer company_id pour tracking
const companyId = await getUserCompanyId(userId);
console.log('ğŸ” DEBUG - Company ID rÃ©cupÃ©rÃ©:', companyId);

console.log('ğŸ” DEBUG - Avant gestion prÃ©fÃ©rences');

// ğŸ§µ GESTION PRÃ‰FÃ‰RENCES ET CACHE (VERSION CORRIGÃ‰E)
let threadId: string;
let finalPreferences: UserPreferences;
let intelligentCacheKey: string;

console.log('ğŸ” DEBUG - providedPreferences:', providedPreferences);

if (providedPreferences?.communication_style && providedPreferences?.content_orientation) {
  console.log('ğŸ” DEBUG - Utilisation prÃ©fÃ©rences frontend');
  finalPreferences = {
    contentLevel: providedPreferences.content_orientation,
    communicationStyle: providedPreferences.communication_style
  };

  console.log('ğŸ” DEBUG - finalPreferences crÃ©Ã©es:', finalPreferences);
  logger.debug('âœ… Utilisation prÃ©fÃ©rences frontend', { finalPreferences });

  // ğŸ†• CACHE INTELLIGENT - VÃ©rifier AVANT tout traitement
  intelligentCacheKey = generateCacheKey(chatbotId, question, {
    // communication_style: finalPreferences.communicationStyle,
    content_level: finalPreferences.contentLevel
  });

  console.log('ğŸš€ CACHE - clÃ© gÃ©nÃ©rÃ©e:', intelligentCacheKey.substring(0, 60) + '...');
  logger.info('ğŸ” CACHE CHECK - VÃ©rification cache intelligent', { 
    cacheKey: intelligentCacheKey.substring(0, 60) + '...',
    botId: chatbotId,
    preferences: finalPreferences
  });

  const cachedResponse = await getCachedResponse(intelligentCacheKey);
  console.log('ğŸ” CACHE - RÃ©ponse trouvÃ©e:', !!cachedResponse);
  
  if (cachedResponse) {
    logger.info('ğŸš€ PERFORMANCE BOOST - RÃ©ponse servie depuis cache', { 
      userId, 
      chatbotId, 
      cacheKey: intelligentCacheKey.substring(0, 60) + '...',
      responseLength: cachedResponse.answer?.length || 0
    });
    return {
      answer: cachedResponse.answer,
      tokens_used: 0, // Ã‰conomie totale tokens
      preferences_applied: finalPreferences
    };
  }

  logger.info('ğŸ” CACHE MISS - Appel OpenAI nÃ©cessaire', { 
    cacheKey: intelligentCacheKey.substring(0, 60) + '...'
  });

console.log('ğŸ” DEBUG - Appel getQuickThread avec userId:', userId);
console.log('ğŸ” DEBUG - Appel getQuickThread avec chatbotId:', chatbotId);
let threadData = await getQuickThread(userId, chatbotId);  // âœ… CHANGÃ‰ en "let"
console.log('ğŸ” DEBUG - threadData retournÃ©e:', threadData);
console.log('ğŸ” DEBUG - threadData.threadId:', threadData.threadId);
threadId = threadData.threadId;
console.log('ğŸ” DEBUG - threadId final assignÃ©:', threadId);


} else {
  console.log('ğŸ” DEBUG - Fallback vers BDD');
  // Fallback : rÃ©cupÃ©rer depuis la base via getQuickThread
  let threadDataBDD = await getQuickThread(userId, chatbotId);  // âœ… RENOMMÃ‰ pour Ã©viter conflit
  threadId = threadDataBDD.threadId;
  finalPreferences = threadDataBDD.preferences;
  console.log('ğŸ” DEBUG - Thread ID rÃ©cupÃ©rÃ© depuis BDD:', threadId);
  logger.debug('âœ… Utilisation prÃ©fÃ©rences BDD', { finalPreferences });

  // ğŸ†• CACHE INTELLIGENT - VÃ©rifier aussi pour le fallback BDD
  intelligentCacheKey = generateCacheKey(chatbotId, question, {
    // communication_style: finalPreferences.communicationStyle,
    content_level: finalPreferences.contentLevel
  });

  logger.info('ğŸ” CACHE CHECK BDD - VÃ©rification cache', { 
    cacheKey: intelligentCacheKey.substring(0, 60) + '...',
    botId: chatbotId 
  });

  const cachedResponse = await getCachedResponse(intelligentCacheKey);
  if (cachedResponse) {
    logger.info('ğŸš€ PERFORMANCE BOOST BDD - Cache hit', { 
      userId, 
      chatbotId, 
      cacheKey: intelligentCacheKey.substring(0, 60) + '...' 
    });
    return {
      answer: cachedResponse.answer,
      tokens_used: 0,
      preferences_applied: finalPreferences
    };
  }

  logger.info('ğŸ” CACHE MISS BDD - Appel OpenAI', { 
    cacheKey: intelligentCacheKey.substring(0, 60) + '...' 
  });
}
// 5. Construire instructions personnalisÃ©es
const customInstructions = buildCustomInstructions(
  finalPreferences.contentLevel, 
  finalPreferences.communicationStyle, 
  chatbotId,
  providedPreferences?.nickname  // âœ… AJOUT DU NICKNAME
);
    
    logger.debug('ğŸ“‹ Instructions personnalisÃ©es gÃ©nÃ©rÃ©es', {
      niveau: finalPreferences.contentLevel,
      style: finalPreferences.communicationStyle
    });

    // 6. Ajouter message utilisateur
    await openai.beta.threads.messages.create(threadId, {
      role: 'user',
      content: question
    });

    // â±ï¸ ğŸš€ DÃ‰MARRAGE CHRONO OPENAI (NOUVEAU)
    const openaiStartTime = Date.now();

// 7. CrÃ©er et exÃ©cuter le run avec instructions personnalisÃ©es
console.log('ğŸ” DEBUG AVANT crÃ©ation run - threadId:', threadId);
console.log('ğŸ” DEBUG AVANT crÃ©ation run - assistantId:', assistantId);

const run = await openai.beta.threads.runs.create(threadId, {
  assistant_id: assistantId,
  // additional_instructions: customInstructions
});

console.log('ğŸ” DEBUG APRÃˆS crÃ©ation run - run:', run);
console.log('ğŸ” DEBUG APRÃˆS crÃ©ation run - run.id:', run.id);
logger.debug('ğŸš€ Run crÃ©Ã© avec instructions personnalisÃ©es', { runId: run.id });
    
    
    // 8. Attendre la complÃ©tion
    // ğŸ”§ CORRECTION - Ajoutez ces logs AVANT l'appel waitForRunCompletion

// Ligne ~430 - AVANT cette ligne :
// const runStatus = await waitForRunCompletion(threadId, run.id);

// AJOUTEZ CES LOGS DE DEBUG :
console.log('ğŸ” DEBUG AVANT waitForRunCompletion - threadId:', threadId);
console.log('ğŸ” DEBUG AVANT waitForRunCompletion - threadId type:', typeof threadId);
console.log('ğŸ” DEBUG AVANT waitForRunCompletion - run.id:', run.id);
console.log('ğŸ” DEBUG AVANT waitForRunCompletion - run.id type:', typeof run.id);

// âœ… VALIDATION AJOUTÃ‰E AVANT L'APPEL
if (!threadId) {
  console.error('âŒ ERREUR CRITIQUE - threadId est undefined avant waitForRunCompletion');
  console.error('âŒ DEBUG - userId:', userId);
  console.error('âŒ DEBUG - chatbotId:', chatbotId);
  throw new Error(`ThreadId est undefined avant waitForRunCompletion. userId: ${userId}, chatbotId: ${chatbotId}`);
}

if (!run.id) {
  console.error('âŒ ERREUR CRITIQUE - run.id est undefined');
  throw new Error(`Run.id est undefined`);
}

// 8. Attendre la complÃ©tion
const runStatus = await waitForRunCompletion(threadId, run.id);
    
    // â±ï¸ ğŸ FIN CHRONO OPENAI (NOUVEAU)
    const openaiResponseTime = Date.now() - openaiStartTime;
    
    if (runStatus.status !== 'completed') {
      throw new Error(`Erreur lors du traitement: ${runStatus.status}`);
    }

    // 9. Extraire la rÃ©ponse et les tokens
    const totalTokens = runStatus?.usage?.total_tokens ?? 0;
    const inputTokens = runStatus?.usage?.prompt_tokens ?? 0;
    const outputTokens = runStatus?.usage?.completion_tokens ?? 0;
    
    const messages = await openai.beta.threads.messages.list(threadId);
    const assistantMessages = messages.data.filter(msg => msg.role === 'assistant');
    const latestMessage = assistantMessages[0];
    const botReply = latestMessage?.content[0]?.text?.value || "DÃ©solÃ©, erreur de rÃ©cupÃ©ration.";

// ğŸ†• SAUVEGARDER EN CACHE avec TTL adaptatif
await setCachedResponse(intelligentCacheKey, { answer: botReply });
logger.info('ğŸ’¾ CACHE INTELLIGENT - RÃ©ponse sauvegardÃ©e', { 
  cacheKey: intelligentCacheKey.substring(0, 60) + '...',
  botId: chatbotId,
  responseLength: botReply.length,
  tokensSaved: totalTokens
});

    // ğŸ’¾ ğŸ†• SAUVEGARDE TOKENS AVEC TEMPS DE RÃ‰PONSE (NOUVEAU)
    if (companyId && totalTokens > 0) {
      await saveTokenUsage({
        user_id: userId,
        company_id: companyId,
        bot_id: chatbotId,
        thread_id: threadId,
        run_id: run.id,
        total_tokens: totalTokens,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        response_time_ms: openaiResponseTime, // âœ… TEMPS RÃ‰EL CAPTURÃ‰
        timestamp: new Date().toISOString()
      });
    }

    const totalProcessingTime = Date.now() - globalStartTime;
    logger.info('âœ… Question traitÃ©e avec succÃ¨s + tokens sauvegardÃ©s', {
      userId,
      chatbotId,
      tokens: totalTokens,
      openaiTime: `${openaiResponseTime}ms`,
      totalTime: `${totalProcessingTime}ms`,
      preferences: finalPreferences
    });

    return {
      answer: botReply,
      tokens_used: totalTokens,
      preferences_applied: finalPreferences
    };

} catch (error) {
    const totalProcessingTime = Date.now() - globalStartTime;
    logger.error('âŒ Erreur traitement question - DÃ‰TAIL COMPLET', {
      userId,
      chatbotId,
      error: (error as Error).message,
      stack: (error as Error).stack,
      totalTime: `${totalProcessingTime}ms`
    });
    console.error('ğŸš¨ ERREUR COMPLÃˆTE:', error);
    throw error;
  }
}

// ğŸ“Š UTILITAIRES DE MONITORING (INCHANGÃ‰)

/**
 * Stats du service OpenAI
 */
export function getOpenAIServiceStats(): {
  availableBots: string[];
  configuredAssistants: number;
} {
  return {
    availableBots: getAvailableBots(),
    configuredAssistants: Object.values(ASSISTANTS).filter(id => id).length
  };
}

// ğŸ§ª FONCTIONS DE TEST (INCHANGÃ‰)

/**
 * Teste la connexion OpenAI
 */
export async function testOpenAIConnection(): Promise<boolean> {
  try {
    const models = await openai.models.list();
    logger.info('âœ… Connexion OpenAI OK', { modelCount: models.data.length });
    return true;
  } catch (error) {
    logger.error('âŒ Connexion OpenAI failed', { error: (error as Error).message });
    return false;
  }
}

/**
 * Teste un assistant spÃ©cifique
 */
/**
 * Teste un assistant spÃ©cifique
 */
export async function testAssistant(chatbotId: string): Promise<boolean> {
  try {
    const assistantId = getAssistantId(chatbotId);
    if (!assistantId) return false;

    const assistant = await openai.beta.assistants.retrieve(assistantId);
    logger.info('âœ… Assistant testÃ©', { chatbotId, assistantName: assistant.name });
    return true;
  } catch (error) {
    logger.error('âŒ Test assistant failed', { chatbotId, error: (error as Error).message });
    return false;
  }
}

/**
 * Test spÃ©cifique pour SANCTIONS RUSSES
 */
export async function testSanctionsAssistant(): Promise<void> {
  try {
    console.log('ğŸ§ª TEST ASSISTANT SANCTIONS RUSSES');
    console.log('ğŸ”‘ API Key (10 premiers chars):', config.openai.apiKey?.substring(0, 10));
    
    const assistantId = 'asst_YmfmThzygMKhSoWoJdwEllo';
    console.log('ğŸ¯ Assistant ID:', assistantId);
    
    const assistant = await openai.beta.assistants.retrieve(assistantId);
    console.log('âœ… Assistant rÃ©cupÃ©rÃ©:', {
      id: assistant.id,
      name: assistant.name,
      model: assistant.model,
      created_at: assistant.created_at
    });
    
    logger.info('âœ… Test SANCTIONS RUSSES rÃ©ussi', { 
      assistantName: assistant.name,
      assistantModel: assistant.model 
    });
    
  } catch (error) {
    console.error('âŒ Erreur test SANCTIONS:', error);
    logger.error('âŒ Test SANCTIONS Ã©chouÃ©', { 
      error: (error as Error).message,
      stack: (error as Error).stack 
    });
  }
}