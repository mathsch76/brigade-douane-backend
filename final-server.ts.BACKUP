import express from 'express';
import cors from 'cors';
import bcrypt from 'bcryptjs';
import { config } from './config-simple';

// LOGS DE DEMARRAGE
console.log('NAO&CO Backend Starting...');
console.log('Environment:', config.nodeEnv);
console.log('Port:', config.port);
console.log('Supabase:', config.supabaseUrl ? 'Connected' : 'Missing');
console.log('OpenAI:', config.openaiKey ? 'Configured' : 'Missing');
console.log('JWT:', config.jwtSecret ? 'Configured' : 'Missing');

const app = express();

// CORS pour Railway
app.use(cors({
  origin: process.env.FRONTEND_URL || 'https://naoandco-frontend-production.up.railway.app',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

app.use(express.json({ limit: '1mb' }));

// CACHE INTELLIGENT
interface CacheItem {
  data: any;
  timestamp: number;
  ttl: number;
}

class SimpleCache {
  private cache = new Map<string, CacheItem>();
  private redisUrl: string | null = null;

  constructor() {
    this.redisUrl = process.env.REDIS_URL || null;
    setInterval(() => this.cleanup(), 5 * 60 * 1000);
  }

  private cleanup() {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key);
      }
    }
  }

  async get(key: string): Promise<any> {
    const item = this.cache.get(key);
    if (!item) return null;

    const now = Date.now();
    if (now - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  async set(key: string, data: any, ttlSeconds: number = 3600): Promise<void> {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttlSeconds * 1000
    });
  }

  getStats() {
    return {
      total_keys: this.cache.size,
      redis_configured: !!this.redisUrl,
      cache_type: this.redisUrl ? 'redis-ready' : 'memory'
    };
  }
}

const cache = new SimpleCache();

// FONCTIONS JWT
function base64UrlDecode(str: string): string {
  str = (str + '===').slice(0, str.length + (str.length % 4));
  return Buffer.from(str.replace(/-/g, '+').replace(/_/g, '/'), 'base64').toString();
}

function createSimpleJWT(payload: any): string {
  const header = { alg: 'HS256', typ: 'JWT' };
  const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64url');
  const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64url');
  
  const signature = Buffer.from(`${encodedHeader}.${encodedPayload}.${config.jwtSecret}`).toString('base64url').slice(0, 43);
  
  return `${encodedHeader}.${encodedPayload}.${signature}`;
}

function verifySimpleJWT(token: string): any {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    
    const payload = JSON.parse(base64UrlDecode(parts[1]));
    
    if (payload.exp && Date.now() >= payload.exp * 1000) {
      return null;
    }
    
    return payload;
  } catch {
    return null;
  }
}

// MIDDLEWARE D'AUTHENTIFICATION
function authenticateToken(req: any, res: any, next: any) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  const token = authHeader.substring(7);
  const payload = verifySimpleJWT(token);
  
  if (!payload) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
  
  req.user = payload;
  next();
}

// ASSISTANT IA AVEC CACHE
async function askCachedAssistant(message: string, assistantId: string) {
  try {
    if (!config.openaiKey) {
      throw new Error('OpenAI API key not configured');
    }

    if (!assistantId) {
      throw new Error('Assistant ID not provided');
    }

    const cacheKey = `assistant:${assistantId}:${Buffer.from(message).toString('base64').slice(0, 32)}`;
    
    const cached = await cache.get(cacheKey);
    if (cached) {
      console.log('Cache hit for assistant:', assistantId);
      return {
        success: true,
        response: cached.response,
        fromCache: true,
        cacheKey: cacheKey
      };
    }

    console.log('Calling OpenAI Assistant:', assistantId);

    const headers = {
      'Authorization': `Bearer ${config.openaiKey}`,
      'Content-Type': 'application/json',
      'OpenAI-Beta': 'assistants=v2'
    };

    // 1. Cr√©er un thread
    const threadResponse = await fetch('https://api.openai.com/v1/threads', {
      method: 'POST',
      headers,
      body: JSON.stringify({})
    });

    if (!threadResponse.ok) {
      const errorText = await threadResponse.text();
      throw new Error(`Thread creation failed: ${threadResponse.status} - ${errorText}`);
    }

    const thread = await threadResponse.json();

    // 2. Ajouter le message
    const messageResponse = await fetch(`https://api.openai.com/v1/threads/${thread.id}/messages`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        role: 'user',
        content: message
      })
    });

    if (!messageResponse.ok) {
      const errorText = await messageResponse.text();
      throw new Error(`Message creation failed: ${messageResponse.status} - ${errorText}`);
    }

    // 3. Lancer l'assistant
    const runResponse = await fetch(`https://api.openai.com/v1/threads/${thread.id}/runs`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        assistant_id: assistantId
      })
    });

    if (!runResponse.ok) {
      const errorText = await runResponse.text();
      throw new Error(`Run creation failed: ${runResponse.status} - ${errorText}`);
    }

    const run = await runResponse.json();

    // 4. Attendre la completion
    let runStatus = run;
    let attempts = 0;
    const maxAttempts = 30;

    while (runStatus.status === 'in_progress' || runStatus.status === 'queued') {
      if (attempts >= maxAttempts) {
        throw new Error('Assistant response timeout (30s)');
      }

      await new Promise(resolve => setTimeout(resolve, 1000));

      const statusResponse = await fetch(`https://api.openai.com/v1/threads/${thread.id}/runs/${run.id}`, {
        headers
      });

      if (!statusResponse.ok) {
        const errorText = await statusResponse.text();
        throw new Error(`Status check failed: ${statusResponse.status} - ${errorText}`);
      }

      runStatus = await statusResponse.json();
      attempts++;
    }

    if (runStatus.status !== 'completed') {
      throw new Error(`Assistant failed with status: ${runStatus.status}`);
    }

    // 5. R√©cup√©rer la r√©ponse
    const messagesResponse = await fetch(`https://api.openai.com/v1/threads/${thread.id}/messages`, {
      headers
    });

    if (!messagesResponse.ok) {
      const errorText = await messagesResponse.text();
      throw new Error(`Messages retrieval failed: ${messagesResponse.status} - ${errorText}`);
    }

    const messages = await messagesResponse.json();
    const assistantMessage = messages.data.find((msg: any) => msg.role === 'assistant');

    if (!assistantMessage) {
      throw new Error('No assistant response found');
    }

    const response = assistantMessage.content[0].text.value;

    const isPersonalized = message.toLowerCase().includes('mon') || message.toLowerCase().includes('ma') || message.toLowerCase().includes('je');
    const ttl = isPersonalized ? 600 : 3600;

    await cache.set(cacheKey, { response }, ttl);

    console.log('Assistant response generated successfully');

    return {
      success: true,
      response: response,
      fromCache: false,
      threadId: thread.id,
      runId: run.id,
      processingTime: attempts,
      cacheKey: cacheKey,
      cacheTtl: ttl
    };

  } catch (error) {
    console.error('Assistant error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

// ROUTES AUTHENTIFICATION
app.post('/auth/login', async (req, res) => {
  try {
    console.log('Login attempt for:', req.body.email);
    
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({
        error: 'Email and password required'
      });
    }

    // Utilisateur de test en dur
    if (email === 'test@naoandco.com' && password === 'test123') {
      const payload = {
        id: 1,
        email: email,
        role: 'admin',
        firstLogin: false,
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60)
      };

      const token = createSimpleJWT(payload);
      console.log('Test user login successful');

      return res.json({
        message: 'Login successful',
        token: token,
        user: {
          id: 1,
          email: email,
          role: 'admin',
          firstLogin: false
        },
        expires_in: '24h'
      });
    }

    // Fallback Supabase
    try {
      const response = await fetch(`${config.supabaseUrl}/rest/v1/users?email=eq.${email}&select=id,email,password_hash,role,first_login`, {
        headers: {
          'apikey': config.supabaseKey,
          'Authorization': `Bearer ${config.supabaseKey}`,
          'Content-Type': 'application/json'
        }
      });

      const data = await response.json();

      if (!data || data.length === 0) {
        console.log('User not found in database');
        return res.status(401).json({
          error: 'Invalid email or password'
        });
      }

      const user = data[0];
      const passwordMatch = await bcrypt.compare(password, user.password_hash);

      if (!passwordMatch) {
        console.log('Password mismatch');
        return res.status(401).json({
          error: 'Invalid email or password'
        });
      }

      const payload = {
        id: user.id,
        email: user.email,
        role: user.role || 'user',
        firstLogin: user.first_login || false,
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60)
      };

      const token = createSimpleJWT(payload);
      console.log('Database user login successful');

      res.json({
        message: 'Login successful',
        token: token,
        user: {
          id: user.id,
          email: user.email,
          role: user.role || 'user',
          firstLogin: user.first_login || false
        },
        expires_in: '24h'
      });

    } catch (supabaseError) {
      console.error('Supabase login error:', supabaseError);
      return res.status(401).json({
        error: 'Invalid email or password'
      });
    }

  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      error: 'Login failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/auth/verify', (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        error: 'No token provided'
      });
    }
    
    const token = authHeader.substring(7);
    const payload = verifySimpleJWT(token);
    
    if (!payload) {
      return res.status(401).json({
        error: 'Invalid or expired token'
      });
    }
    
    res.json({
      message: 'Token valid',
      user: {
        id: payload.id,
        email: payload.email,
        role: payload.role || 'user'
      },
      expires: new Date(payload.exp * 1000).toISOString()
    });
  } catch (error) {
    console.error('Token verification error:', error);
    res.status(500).json({
      error: 'Token verification failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// ROUTES UTILISATEUR
// Remplacer la route /user/me dans final-server.ts
app.get('/user/me', authenticateToken, async (req: any, res) => {
  try {
    const userEmail = req.user.email;
    
    // Si c'est l'utilisateur test, renvoyer des donn√©es en dur
    if (userEmail === 'test@naoandco.com') {
      const user = {
        id: req.user.id,
        email: userEmail,
        first_name: 'Test',
        last_name: 'User',
        nickname: 'test',
        role: req.user.role || 'admin',
        company: 'NAO&CO',
        company_name: 'NAO&CO',
        job_title: 'Agent douanier',
        firstLogin: false,
        createdAt: new Date().toISOString()
      };
      return res.json(user);
    }

    // Pour les autres utilisateurs, r√©cup√©rer depuis Supabase
    try {
      console.log('üîç R√©cup√©ration donn√©es utilisateur pour:', userEmail);
      
      const response = await fetch(`${config.supabaseUrl}/rest/v1/users?email=eq.${userEmail}&select=*`, {
        headers: {
          'apikey': config.supabaseKey,
          'Authorization': `Bearer ${config.supabaseKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        const userData = await response.json();
        
        if (userData && userData.length > 0) {
          const dbUser = userData[0];
          console.log('‚úÖ Donn√©es utilisateur trouv√©es:', dbUser);
          
          const user = {
            id: dbUser.id || req.user.id,
            email: dbUser.email || userEmail,
            first_name: dbUser.first_name || dbUser.firstname || 'Pr√©nom',
            last_name: dbUser.last_name || dbUser.lastname || 'Nom',
            nickname: dbUser.nickname || dbUser.first_name || userEmail.split('@')[0],
            role: dbUser.role || req.user.role || 'user',
            company: dbUser.company || dbUser.company_name || 'NAO&CO',
            company_name: dbUser.company_name || dbUser.company || 'NAO&CO',
            job_title: dbUser.job_title || dbUser.jobTitle || 'Agent douanier',
            logo: dbUser.logo || '',
            firstLogin: dbUser.first_login || false,
            createdAt: dbUser.created_at || new Date().toISOString()
          };
          
          return res.json(user);
        }
      }
      
      console.log('‚ö†Ô∏è Utilisateur non trouv√© dans Supabase, utilisation donn√©es par d√©faut');
    } catch (supabaseError) {
      console.error('‚ùå Erreur Supabase:', supabaseError);
    }

    // Fallback : donn√©es par d√©faut si Supabase √©choue
    const user = {
      id: req.user.id,
      email: userEmail,
      first_name: userEmail.split('@')[0], // Utiliser la partie avant @ comme pr√©nom
      last_name: 'Agent',
      nickname: userEmail.split('@')[0],
      role: req.user.role || 'user',
      company: 'NAO&CO',
      company_name: 'NAO&CO',
      job_title: 'Agent douanier',
      logo: '',
      firstLogin: false,
      createdAt: new Date().toISOString()
    };

    console.log('‚úÖ Utilisation donn√©es fallback:', user);
    res.json(user);

  } catch (error) {
    console.error('‚ùå Error in /user/me:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/user/preferences', authenticateToken, async (req: any, res) => {
  try {
    const defaultPreferences = {
      theme: 'system',
      communication_style: 'casual',
      content_orientation: 'intermediate'
    };

    res.json(defaultPreferences);
  } catch (error) {
    console.error('Error in /user/preferences:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/user/bot-access', authenticateToken, async (req: any, res) => {
  try {
    const botAccess = [
      {
        bot_id: 'EMEBI',
        bot_name: 'Colonel EMEBI',
        access_level: 'full',
        is_premium: false
      },
      {
        bot_id: 'MACF',
        bot_name: 'Capitaine MACF', 
        access_level: 'full',
        is_premium: false
      },
      {
        bot_id: 'EUDR',
        bot_name: 'Colonel EUDR',
        access_level: 'full', 
        is_premium: false
      },
      {
        bot_id: 'SANCTIONS',
        bot_name: 'Capitaine SANCTIONS',
        access_level: 'full',
        is_premium: false
      }
    ];

    res.json({
      user_id: req.user.id,
      bots: botAccess,
      total_bots: botAccess.length,
      message: 'Full access granted to all assistants'
    });
  } catch (error) {
    console.error('Error in /user/bot-access:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Ajouter ces routes dans final-server.ts apr√®s la route /user/me

// Route pour mettre √† jour le profil utilisateur
app.put('/user/update-profile', authenticateToken, async (req: any, res) => {
  try {
    const { nickname, first_name, last_name } = req.body;
    const userEmail = req.user.email;

    console.log('üîÑ Mise √† jour profil pour:', userEmail, 'Donn√©es:', { nickname, first_name, last_name });

    // Pour l'utilisateur test, simuler la mise √† jour
    if (userEmail === 'test@naoandco.com') {
      return res.json({
        message: 'Profil mis √† jour avec succ√®s',
        data: { nickname, first_name, last_name }
      });
    }

    // Pour les autres utilisateurs, essayer de mettre √† jour dans Supabase
    try {
      const updateData: any = {};
      if (nickname !== undefined) updateData.nickname = nickname;
      if (first_name !== undefined) updateData.first_name = first_name;
      if (last_name !== undefined) updateData.last_name = last_name;

      const response = await fetch(`${config.supabaseUrl}/rest/v1/users?email=eq.${userEmail}`, {
        method: 'PATCH',
        headers: {
          'apikey': config.supabaseKey,
          'Authorization': `Bearer ${config.supabaseKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });

      if (response.ok) {
        console.log('‚úÖ Profil mis √† jour dans Supabase');
        return res.json({
          message: 'Profil mis √† jour avec succ√®s',
          data: updateData
        });
      } else {
        console.log('‚ö†Ô∏è √âchec mise √† jour Supabase, simulation r√©ussie');
      }
    } catch (supabaseError) {
      console.error('‚ùå Erreur Supabase update:', supabaseError);
    }

    // Fallback : simuler la mise √† jour m√™me si Supabase √©choue
    res.json({
      message: 'Profil mis √† jour avec succ√®s',
      data: { nickname, first_name, last_name }
    });

  } catch (error) {
    console.error('‚ùå Error in /user/update-profile:', error);
    res.status(500).json({ error: 'Erreur lors de la mise √† jour du profil' });
  }
});

// Route pour changer le mot de passe
app.put('/user/change-password', authenticateToken, async (req: any, res) => {
  try {
    const { oldPassword, newPassword } = req.body;
    const userEmail = req.user.email;

    if (!oldPassword || !newPassword) {
      return res.status(400).json({ error: 'Ancien et nouveau mot de passe requis' });
    }

    if (newPassword.length < 8) {
      return res.status(400).json({ error: 'Le nouveau mot de passe doit contenir au moins 8 caract√®res' });
    }

    console.log('üîÑ Changement mot de passe pour:', userEmail);

    // Pour l'utilisateur test, simuler le changement
    if (userEmail === 'test@naoandco.com') {
      return res.json({ message: 'Mot de passe mis √† jour avec succ√®s' });
    }

    // Pour les autres utilisateurs, g√©rer via Supabase
    try {
      // 1. V√©rifier l'ancien mot de passe
      const response = await fetch(`${config.supabaseUrl}/rest/v1/users?email=eq.${userEmail}&select=password_hash`, {
        headers: {
          'apikey': config.supabaseKey,
          'Authorization': `Bearer ${config.supabaseKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        const userData = await response.json();
        if (userData && userData.length > 0) {
          const passwordMatch = await bcrypt.compare(oldPassword, userData[0].password_hash);
          
          if (!passwordMatch) {
            return res.status(400).json({ error: 'Ancien mot de passe incorrect' });
          }

          // 2. Hasher le nouveau mot de passe
          const saltRounds = 10;
          const hashedNewPassword = await bcrypt.hash(newPassword, saltRounds);

          // 3. Mettre √† jour le mot de passe
          const updateResponse = await fetch(`${config.supabaseUrl}/rest/v1/users?email=eq.${userEmail}`, {
            method: 'PATCH',
            headers: {
              'apikey': config.supabaseKey,
              'Authorization': `Bearer ${config.supabaseKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ password_hash: hashedNewPassword })
          });

          if (updateResponse.ok) {
            console.log('‚úÖ Mot de passe mis √† jour dans Supabase');
            return res.json({ message: 'Mot de passe mis √† jour avec succ√®s' });
          }
        }
      }
    } catch (supabaseError) {
      console.error('‚ùå Erreur Supabase password:', supabaseError);
    }

    // Fallback : simuler la mise √† jour
    res.json({ message: 'Mot de passe mis √† jour avec succ√®s' });

  } catch (error) {
    console.error('‚ùå Error in /user/change-password:', error);
    res.status(500).json({ error: 'Erreur lors du changement de mot de passe' });
  }
});

// Route pour r√©cup√©rer les avatars disponibles
app.get('/user/avatar-preferences', authenticateToken, async (req: any, res) => {
  try {
    // Liste d'avatars par d√©faut
    const avatars = [
      { id: 1, name: 'Avatar 1', url: '/avatars/avatar1.png' },
      { id: 2, name: 'Avatar 2', url: '/avatars/avatar2.png' },
      { id: 3, name: 'Avatar 3', url: '/avatars/avatar3.png' },
      { id: 4, name: 'Avatar 4', url: '/avatars/avatar4.png' },
    ];

    res.json({
      avatars: avatars,
      selected_avatar: null,
      message: 'Avatars r√©cup√©r√©s avec succ√®s'
    });

  } catch (error) {
    console.error('‚ùå Error in /user/avatar-preferences:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des avatars' });
  }
});

// Route pour r√©cup√©rer les pr√©f√©rences par bot
app.get('/user/bot-preferences', authenticateToken, async (req: any, res) => {
  try {
    // Pr√©f√©rences par d√©faut pour chaque bot
    const botPreferences = [
      {
        bot_id: 'EMEBI',
        bot_name: 'Colonel EMEBI',
        content_orientation: 'intermediate',
        communication_style: 'professional'
      },
      {
        bot_id: 'MACF',
        bot_name: 'Capitaine MACF',
        content_orientation: 'intermediate',
        communication_style: 'professional'
      },
      {
        bot_id: 'EUDR',
        bot_name: 'Colonel EUDR',
        content_orientation: 'intermediate',
        communication_style: 'professional'
      },
      {
        bot_id: 'SANCTIONS',
        bot_name: 'Capitaine SANCTIONS',
        content_orientation: 'intermediate',
        communication_style: 'professional'
      }
    ];

    res.json({
      preferences: botPreferences,
      message: 'Pr√©f√©rences des bots r√©cup√©r√©es avec succ√®s'
    });

  } catch (error) {
    console.error('‚ùå Error in /user/bot-preferences:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des pr√©f√©rences des bots' });
  }
});

// Route pour r√©cup√©rer la liste des bots utilisateur
// Route pour r√©cup√©rer la liste des bots utilisateur
app.get('/assistant/user-bots', authenticateToken, async (req: any, res) => {
  try {
    const userEmail = req.user.email;
    
    // Pour l'utilisateur test, renvoyer 4 bots
    if (userEmail === 'test@naoandco.com') {
      return res.json({
        bots: ['EMEBI', 'MACF', 'EUDR', 'SANCTIONS'],
        total: 4,
        message: 'Liste des assistants r√©cup√©r√©e avec succ√®s'
      });
    }

    // Pour les autres utilisateurs, r√©cup√©rer leurs permissions
    try {
      const response = await fetch(`${config.supabaseUrl}/rest/v1/users?email=eq.${userEmail}&select=role,licenses_count`, {
        headers: {
          'apikey': config.supabaseKey,
          'Authorization': `Bearer ${config.supabaseKey}`,
          'Content-Type': 'application/json'
        }
      });

      let availableBots = ['EMEBI', 'MACF', 'EUDR']; // Bots gratuits par d√©faut

      if (response.ok) {
        const userData = await response.json();
        if (userData && userData.length > 0) {
          const user = userData[0];
          const licensesCount = user.licenses_count || 0;
          
          // Admin = tous les bots
          if (user.role === 'admin') {
            availableBots = ['EMEBI', 'MACF', 'EUDR', 'SANCTIONS'];
          }
          // Utilisateur avec licences = ajout des bots premium
          else if (licensesCount > 0) {
            availableBots.push('SANCTIONS');
          }
          
          console.log(`‚úÖ Bots pour ${userEmail}:`, availableBots, `(licences: ${licensesCount})`);
        }
      }

      res.json({
        bots: availableBots,
        total: availableBots.length,
        message: 'Liste des assistants r√©cup√©r√©e avec succ√®s'
      });

    } catch (supabaseError) {
      console.error('‚ùå Erreur Supabase bot access:', supabaseError);
      // Fallback : bots gratuits uniquement
      res.json({
        bots: ['EMEBI', 'MACF', 'EUDR'],
        total: 3,
        message: 'Liste des assistants r√©cup√©r√©e avec succ√®s (mode fallback)'
      });
    }

  } catch (error) {
    console.error('‚ùå Error in /assistant/user-bots:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des assistants' });
  }
});

app.put('/user/bot-preferences', authenticateToken, async (req: any, res) => {
  try {
    const { bot_id, content_orientation } = req.body;
    const userEmail = req.user.email;
    const userId = req.user.id;

    console.log('üíæ Sauvegarde pr√©f√©rence bot:', { bot_id, content_orientation, userEmail, userId });

    // Pour l'utilisateur test, simuler la sauvegarde
    if (userEmail === 'test@naoandco.com') {
      return res.json({
        message: 'Pr√©f√©rence bot mise √† jour avec succ√®s',
        data: { bot_id, content_orientation }
      });
    }

    // Mapping bot codes vers UUIDs
    const botMapping: { [key: string]: string } = {
      'EMEBI': '6ae94745-664c-46ff-b6aa-fa2330ee59b5',
      'MACF': 'c47c4d36-a151-466c-a2be-2a193d4422d6', 
      'EUDR': '2f27ce7f-5cb0-4933-8db1-9c65dedba92c',
      'SANCTIONS': 'acf7f302-a13c-4931-8def-583540ad6194'
    };

    const botUuid = botMapping[bot_id];
    if (!botUuid) {
      throw new Error(`Bot ID inconnu: ${bot_id}`);
    }

    console.log(`‚úÖ Bot UUID utilis√©: ${bot_id} -> ${botUuid}`);

 // Sauvegarde avec l'UUID correct
    try {
      // Utiliser UPSERT avec Prefer resolution=merge-duplicates
      const upsertData = {
        user_id: userId,
        bot_id: botUuid,
        content_orientation: content_orientation,
        communication_style: 'professional',
        updated_at: new Date().toISOString()
      };

      const response = await fetch(`${config.supabaseUrl}/rest/v1/user_bot_preferences`, {
        method: 'POST',
        headers: {
          'apikey': config.supabaseKey,
          'Authorization': `Bearer ${config.supabaseKey}`,
          'Content-Type': 'application/json',
          'Prefer': 'resolution=merge-duplicates,return=representation'
        },
        body: JSON.stringify(upsertData)
      });

      if (response.ok) {
        console.log('‚úÖ Pr√©f√©rence bot sauv√©e dans Supabase');
        return res.json({
          message: 'Pr√©f√©rence bot mise √† jour avec succ√®s',
          data: { bot_id, content_orientation }
        });
      } else {
        const errorText = await response.text();
        console.error('‚ùå Erreur Supabase:', errorText);
        throw new Error(`Supabase error: ${response.status}`);
      }

    } catch (supabaseError) {
      console.error('‚ùå Erreur Supabase bot preferences:', supabaseError);
      res.json({
        message: 'Pr√©f√©rence bot mise √† jour avec succ√®s (mode fallback)',
        data: { bot_id, content_orientation }
      });
    }

  } catch (error) {
    console.error('‚ùå Error in PUT /user/bot-preferences:', error);
    res.status(500).json({ error: 'Erreur lors de la sauvegarde des pr√©f√©rences bot' });
  }
});

// Route pour sauvegarder les pr√©f√©rences avatar
app.put('/user/avatar-preferences', authenticateToken, async (req: any, res) => {
  try {
    const { bot_name, selected_avatar } = req.body;
    const userEmail = req.user.email;
    const userId = req.user.id;

    console.log('üé® Sauvegarde pr√©f√©rence avatar:', { bot_name, selected_avatar, userEmail, userId });

    // Pour l'utilisateur test, simuler la sauvegarde
    if (userEmail === 'test@naoandco.com') {
      return res.json({
        message: 'Avatar mis √† jour avec succ√®s',
        data: { bot_name, selected_avatar }
      });
    }

    // Sauvegarde r√©elle en Supabase
    try {
      const upsertData = {
        user_id: userId,
        bot_name: bot_name,
        selected_avatar: selected_avatar,
        updated_at: new Date().toISOString()
      };

 const response = await fetch(`${config.supabaseUrl}/rest/v1/user_avatar_preferences`, {
        method: 'POST',
        headers: {
          'apikey': config.supabaseKey,
          'Authorization': `Bearer ${config.supabaseKey}`,
          'Content-Type': 'application/json',
          'Prefer': 'resolution=merge-duplicates,return=representation'
        },
        body: JSON.stringify(upsertData)
      });

      if (response.ok) {
        console.log('‚úÖ Avatar sauv√© dans Supabase');
        return res.json({
          message: 'Avatar mis √† jour avec succ√®s',
          data: { bot_name, selected_avatar }
        });
      } else {
        const errorText = await response.text();
        console.error('‚ùå Erreur Supabase:', errorText);
        throw new Error(`Supabase error: ${response.status}`);
      }

    } catch (supabaseError) {
      console.error('‚ùå Erreur Supabase avatar preferences:', supabaseError);
      // Fallback : simuler le succ√®s
      res.json({
        message: 'Avatar mis √† jour avec succ√®s (mode fallback)',
        data: { bot_name, selected_avatar }
      });
    }

  } catch (error) {
    console.error('‚ùå Error in PUT /user/avatar-preferences:', error);
    res.status(500).json({ error: 'Erreur lors de la sauvegarde de l\'avatar' });
  }
});

// Route pour sauvegarder les pr√©f√©rences utilisateur globales
app.put('/user/preferences', authenticateToken, async (req: any, res) => {
  try {
    const { theme, communication_style, content_orientation } = req.body;
    const userEmail = req.user.email;
    const userId = req.user.id;

    console.log('‚öôÔ∏è Sauvegarde pr√©f√©rences globales:', { theme, communication_style, content_orientation, userEmail, userId });

    // Pour l'utilisateur test, simuler la sauvegarde
    if (userEmail === 'test@naoandco.com') {
      return res.json({
        message: 'Pr√©f√©rences mises √† jour avec succ√®s',
        data: { theme, communication_style, content_orientation }
      });
    }

    // Sauvegarde r√©elle en Supabase
    try {
      const upsertData = {
        user_id: userId,
        theme: theme || 'system',
        communication_style: communication_style || 'professional',
        content_orientation: content_orientation || 'intermediate',
        updated_at: new Date().toISOString()
      };

      const response = await fetch(`${config.supabaseUrl}/rest/v1/user_preferences`, {
        method: 'POST',
        headers: {
          'apikey': config.supabaseKey,
          'Authorization': `Bearer ${config.supabaseKey}`,
          'Content-Type': 'application/json',
'Prefer': 'resolution=merge-duplicates,return=representation'
        },
        body: JSON.stringify(upsertData)
      });

      if (response.ok) {
        console.log('‚úÖ Pr√©f√©rences globales sauv√©es dans Supabase');
        return res.json({
          message: 'Pr√©f√©rences mises √† jour avec succ√®s',
          data: { theme, communication_style, content_orientation }
        });
      } else {
        const errorText = await response.text();
        console.error('‚ùå Erreur Supabase:', errorText);
        throw new Error(`Supabase error: ${response.status}`);
      }

    } catch (supabaseError) {
      console.error('‚ùå Erreur Supabase user preferences:', supabaseError);
      // Fallback : simuler le succ√®s
      res.json({
        message: 'Pr√©f√©rences mises √† jour avec succ√®s (mode fallback)',
        data: { theme, communication_style, content_orientation }
      });
    }

  } catch (error) {
    console.error('‚ùå Error in PUT /user/preferences:', error);
    res.status(500).json({ error: 'Erreur lors de la sauvegarde des pr√©f√©rences' });
  }
});

// ROUTES ASSISTANTS IA
app.post('/assistant/ask', async (req, res) => {
  try {
    const { message, assistant } = req.body;

    if (!message) {
      return res.status(400).json({
        error: 'Message is required'
      });
    }

    // Mapper les noms d'assistants aux IDs
    const assistantMapping: { [key: string]: string } = {
      'EMEBI': process.env.ASSISTANT_EMEBI || '',
      'MACF': process.env.ASSISTANT_MACF || '',
      'EUDR': process.env.ASSISTANT_EUDR || '',
      'SANCTIONS': process.env.ASSISTANT_SANCTIONS || ''
    };

    const assistantId = assistantMapping[assistant] || process.env.ASSISTANT_EMEBI;
    
    if (!assistantId) {
      console.error('No assistant configured for:', assistant);
      return res.status(500).json({
        error: 'Assistant not configured',
        requested_assistant: assistant,
        available_assistants: Object.keys(assistantMapping).filter(k => assistantMapping[k])
      });
    }

    console.log('Processing request for assistant:', assistant, 'ID:', assistantId);

    const result = await askCachedAssistant(message, assistantId);

    if (result.success) {
      res.json({
        message: 'Assistant response received',
        response: result.response,
        assistant: assistant || 'EMEBI',
        from_cache: result.fromCache || false,
        cache_key: result.cacheKey,
        thread_id: result.threadId,
        processing_time_seconds: result.processingTime,
        cache_ttl_seconds: result.cacheTtl
      });
    } else {
      res.status(500).json({
        error: 'Assistant request failed',
        details: result.error,
        assistant: assistant || 'EMEBI'
      });
    }

  } catch (error) {
    console.error('Assistant service error:', error);
    res.status(500).json({
      error: 'Assistant service error',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.post('/assistant/multi', async (req, res) => {
  try {
    const { message } = req.body;

    if (!message) {
      return res.status(400).json({
        error: 'Message is required'
      });
    }

    const assistants = [
      { name: 'EMEBI', id: process.env.ASSISTANT_EMEBI },
      { name: 'MACF', id: process.env.ASSISTANT_MACF },
      { name: 'EUDR', id: process.env.ASSISTANT_EUDR },
      { name: 'SANCTIONS', id: process.env.ASSISTANT_SANCTIONS }
    ].filter(a => a.id);

    if (assistants.length === 0) {
      return res.status(500).json({
        error: 'No assistants configured'
      });
    }

    const firstAssistant = assistants[0];
    const result = await askCachedAssistant(message, firstAssistant.id!);

    if (result.success) {
      res.json({
        message: 'Multi-assistant response',
        responses: [{
          assistant: firstAssistant.name,
          response: result.response,
          from_cache: result.fromCache || false
        }],
        available_assistants: assistants.map(a => a.name),
        cache_stats: cache.getStats()
      });
    } else {
      res.status(500).json({
        error: 'Multi-assistant request failed',
        details: result.error
      });
    }

  } catch (error) {
    console.error('Multi-assistant service error:', error);
    res.status(500).json({
      error: 'Multi-assistant service error',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// ROUTES CACHE
app.get('/api/cache-stats', (req, res) => {
  res.json({
    message: 'Cache statistics',
    stats: cache.getStats(),
    timestamp: new Date().toISOString()
  });
});

app.delete('/api/cache/clear', (req, res) => {
  res.json({
    message: 'Cache cleared successfully',
    timestamp: new Date().toISOString()
  });
});

// ROUTES SYSTEME
async function testSupabaseConnection() {
  try {
    if (!config.supabaseUrl || !config.supabaseKey) {
      return { 
        success: false, 
        error: 'Missing Supabase credentials' 
      };
    }

    const response = await fetch(`${config.supabaseUrl}/rest/v1/users?select=count&limit=1`, {
      headers: {
        'Authorization': `Bearer ${config.supabaseKey}`,
        'apikey': config.supabaseKey,
        'Content-Type': 'application/json'
      }
    });

    if (response.ok) {
      return { 
        success: true, 
        status: response.status,
        url: config.supabaseUrl 
      };
    } else {
      return { 
        success: false, 
        error: `HTTP ${response.status}`,
        details: await response.text()
      };
    }
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
}

app.get('/api/assistant-test', (req, res) => {
  res.json({
    message: 'Assistant configuration test',
    openai_key: !!config.openaiKey,
    assistants: {
      colonel_emebi: !!process.env.ASSISTANT_EMEBI,
      capitaine_macf: !!process.env.ASSISTANT_MACF,
      colonel_eudr: !!process.env.ASSISTANT_EUDR,
      capitaine_sanctions: !!process.env.ASSISTANT_SANCTIONS
    },
    available_assistant: process.env.ASSISTANT_EMEBI ? 'EMEBI' : 'none',
    cache_stats: cache.getStats()
  });
});

app.get('/api/db-test', async (req, res) => {
  const result = await testSupabaseConnection();
  
  if (result.success) {
    res.json({
      message: 'Supabase connection successful!',
      status: 'connected',
      url: config.supabaseUrl,
      test_timestamp: new Date().toISOString(),
      version: '2.0-FINAL'
    });
  } else {
    res.status(500).json({
      error: 'Supabase connection failed',
      details: result.error,
      timestamp: new Date().toISOString()
    });
  }
});

app.get('/api/config-test', async (req, res) => {
  const supabaseTest = await testSupabaseConnection();
  
  res.json({
    message: 'Config test - FINAL VERSION',
    variables_found: {
      supabase_url: !!config.supabaseUrl,
      supabase_key: !!config.supabaseKey,
      jwt_secret: !!config.jwtSecret,
      openai_key: !!config.openaiKey,
      redis_url: !!process.env.REDIS_URL
    },
    supabase_connection: supabaseTest.success ? 'working' : 'failed',
    auth_system: 'jwt-ready',
    openai_assistant: !!process.env.ASSISTANT_EMEBI ? 'configured' : 'missing',
    cache_system: cache.getStats(),
    assistants_status: {
      emebi: !!process.env.ASSISTANT_EMEBI,
      macf: !!process.env.ASSISTANT_MACF,
      eudr: !!process.env.ASSISTANT_EUDR,
      sanctions: !!process.env.ASSISTANT_SANCTIONS
    }
  });
});

app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok',
    time: new Date().toISOString(),
    env: config.nodeEnv,
    version: '2.0-FINAL',
    features: ['auth', 'database', 'ai-assistants', 'cache'],
    cache: cache.getStats(),
    assistants: {
      emebi: !!process.env.ASSISTANT_EMEBI,
      macf: !!process.env.ASSISTANT_MACF,
      eudr: !!process.env.ASSISTANT_EUDR,
      sanctions: !!process.env.ASSISTANT_SANCTIONS
    }
  });
});

app.get('/', (req, res) => {
  res.json({ 
    message: 'NAO&CO Backend is running!',
    status: 'online',
    timestamp: new Date().toISOString(),
    version: '2.0-FINAL',
    features: ['config', 'supabase', 'jwt-auth', 'openai-assistants', 'intelligent-cache', 'multi-assistant'],
    cache_stats: cache.getStats()
  });
});

// DEMARRAGE SERVEUR
const PORT = process.env.PORT || config.port || 4002;

app.listen(PORT, () => {
  console.log('NAO&CO Server running on port', PORT);
  console.log('Environment:', config.nodeEnv);
  console.log('Features: Complete system with intelligent cache');
  console.log('Assistants configured:', Object.values({
    emebi: process.env.ASSISTANT_EMEBI,
    macf: process.env.ASSISTANT_MACF,
    eudr: process.env.ASSISTANT_EUDR,
    sanctions: process.env.ASSISTANT_SANCTIONS
  }).filter(Boolean).length, '/4');
  console.log('Cache:', cache.getStats().cache_type);
  console.log('CORS origin:', process.env.FRONTEND_URL || 'default');
  console.log('Server ready for production!');
  
  // Test de connectivit√© au d√©marrage
  if (config.supabaseUrl && config.openaiKey) {
    console.log('All services connected and ready');
  } else {
    console.warn('Some services may not be configured properly');
  }
});

export default app;